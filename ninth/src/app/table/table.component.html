<table mat-table [dataSource]="heroes" matSort matSortDisableClear="true">
  <ng-container matColumnDef="id">
    <th mat-header-cell *matHeaderCellDef> ID </th>
    <td mat-cell *matCellDef="let hero"> {{hero.id}} </td>
  </ng-container>
  <ng-container matColumnDef="name">
    <th mat-header-cell *matHeaderCellDef mat-sort-header> Name </th>
    <td mat-cell *matCellDef="let hero"> {{hero.name}} </td>
  </ng-container>
  <tr mat-header-row *matHeaderRowDef="columnNames"></tr>
  <tr mat-row *matRowDef="let row; columns: columnNames;"></tr>
</table>

<!--
The dataSource property of the mat-table directive defines the data that we
want to display on the table. It can be any sort of data that can be enumerated, such as
an observable stream or an array. In our case, we bind it to the heroes array that we
declared in our component class, along with the columnNames property that indicates
the column names of the table
-->
<!--
The names of columns match the properties of a hero object and are used twice in the
table elementâ€”once to define the header row of the table that displays the names of the
columns and the second time to define the actual rows that contain data

Also added CSS with table class width to 50% for better clarity.
-->

<!--
  Sorting:

  MatSortModule exports a variety of directives that we can use to sort a table. Add
  the matSort and matSortDisableClear directives to the table element and
  add the mat-sort-header directive to each header cell that you want to sort.

  We set the value of the matSortDisableClear directive to true because
  sorting by default contains three states: ascending, descending, and the original
  ordering. The last one clears the ordering, and that is why we disable it.

  Use the @ViewChild decorator to get a reference to the matSort directive that
  we defined earlier:
  
  @ViewChild(MatSort, {static: true}) sort: MatSort;
-->
